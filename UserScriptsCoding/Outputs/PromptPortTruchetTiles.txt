// --- Source Blob ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookDefinition.cs ---

using UnityEngine;

namespace Truchet
{
    [CreateAssetMenu(
        fileName = "TileCookDefinition",
        menuName = "Truchet/Tile Cooking/Tile Cook Definition",
        order = 0)]
    public class TileCookDefinition : ScriptableObject
    {
        [Header("Resolution")]
        public int Width = 256;
        public int Height = 256;

        [Header("Winged Mode")]
        public bool IsWinged;

        [Header("Output Folder (relative to Assets/)")]
        public string OutputFolder = "Core/Textures/Tiles";

        [Header("Topology")]
        public TileTopology Topology;

        [Header("Command Script")]
        [TextArea(10, 40)]
        public string CommandScript;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookDefinition.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\GridCell.cs ---

// TODO ROADMAP:
// [x] Basic grid cell data container
// [x] Rotation support (0-3)
// [x] TileSetId support (multi-tileset rendering)
// [ ] Add metadata storage
// [ ] Add flags (blocked, reserved, etc.)
// [ ] Add multiscale support hook

namespace Truchet
{
    /// <summary>
    /// Logical grid cell.
    /// Pure topology container.
    /// </summary>
    public struct GridCell
    {
        public int X;
        public int Y;

        public int TileSetId;  
        public int TileIndex;
        public int Rotation;    // 0,1,2,3 (90° steps)

        public GridCell(int x, int y)
        {
            X = x;
            Y = y;
            TileSetId = -1;
            TileIndex = -1;
            Rotation = 0;
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\GridCell.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\QuadTree\QuadTreeTileMap.cs ---

// TODO ROADMAP:
// [x] Stable node index QuadTree
// [x] Canonical child order
// [x] Free list reuse
// [x] Spatial traversal grid access
// [x] Uniform depth detection
// [x] Mutable structure
// [ ] Add deterministic random build helper
// [ ] Add adjacency helpers
// [ ] Add debug validation tools

using System;
using System.Collections.Generic;

namespace Truchet
{
    public class QuadTreeTileMap : IGridLayout, IHierarchicalTileLayout
    {
        private struct QuadNode
        {
            public float X;
            public float Y;
            public float Size;
            public int Level;

            public bool IsLeaf;
            public bool IsActive;

            public int ChildIndex;

            public int TileSetId;
            public int TileIndex;
            public int Rotation;
        }

        private readonly List<QuadNode> _nodes = new List<QuadNode>();
        private readonly Stack<int> _freeIndices = new Stack<int>();

        private bool _isUniformDepth;
        private int _uniformDepth;

        public int NodeCount => _nodes.Count;

        public int LeafCount
        {
            get
            {
                int count = 0;
                for (int i = 0; i < _nodes.Count; i++)
                {
                    if (_nodes[i].IsActive && _nodes[i].IsLeaf)
                        count++;
                }
                return count;
            }
        }

        public bool IsUniformDepth => _isUniformDepth;
        public int UniformDepth => _uniformDepth;

        // --------------------------------------------------

        public QuadTreeTileMap(float size = 1f)
        {
            _nodes.Add(new QuadNode
            {
                X = 0f,
                Y = 0f,
                Size = size,
                Level = 0,
                IsLeaf = true,
                IsActive = true,
                ChildIndex = -1,
                TileSetId = -1,
                TileIndex = -1,
                Rotation = 0
            });

            RecalculateUniformState();
        }

        // --------------------------------------------------
        // Subdivision
        // --------------------------------------------------

        public void Subdivide(int nodeIndex)
        {
            ValidateNodeIndex(nodeIndex);

            var node = _nodes[nodeIndex];

            if (!node.IsActive || !node.IsLeaf)
                return;

            float half = node.Size * 0.5f;
            int level = node.Level + 1;

            int childStart = AllocateChildBlock();

            node.IsLeaf = false;
            node.ChildIndex = childStart;
            _nodes[nodeIndex] = node;

            // Canonical order:
            // 0 = bottom-left
            // 1 = bottom-right
            // 2 = top-left
            // 3 = top-right

            CreateChild(childStart + 0, node, 0f, 0f, half, level);
            CreateChild(childStart + 1, node, half, 0f, half, level);
            CreateChild(childStart + 2, node, 0f, half, half, level);
            CreateChild(childStart + 3, node, half, half, half, level);

            RecalculateUniformState();
        }

        public void Collapse(int nodeIndex)
        {
            ValidateNodeIndex(nodeIndex);

            var node = _nodes[nodeIndex];

            if (!node.IsActive || node.IsLeaf)
                return;

            int childStart = node.ChildIndex;

            var child0 = _nodes[childStart + 0];

            node.TileSetId = child0.TileSetId;
            node.TileIndex = child0.TileIndex;
            node.Rotation = child0.Rotation;

            for (int i = 0; i < 4; i++)
            {
                int ci = childStart + i;
                var child = _nodes[ci];
                child.IsActive = false;
                _nodes[ci] = child;
                _freeIndices.Push(ci);
            }

            node.IsLeaf = true;
            node.ChildIndex = -1;
            _nodes[nodeIndex] = node;

            RecalculateUniformState();
        }

        private void CreateChild(int index, QuadNode parent,
            float offsetX, float offsetY, float size, int level)
        {
            EnsureNodeCapacity(index);

            _nodes[index] = new QuadNode
            {
                X = parent.X + offsetX,
                Y = parent.Y + offsetY,
                Size = size,
                Level = level,
                IsLeaf = true,
                IsActive = true,
                ChildIndex = -1,
                TileSetId = parent.TileSetId,
                TileIndex = parent.TileIndex,
                Rotation = parent.Rotation
            };
        }

        private int AllocateChildBlock()
        {
            if (_freeIndices.Count >= 4)
            {
                int a = _freeIndices.Pop();
                int b = _freeIndices.Pop();
                int c = _freeIndices.Pop();
                int d = _freeIndices.Pop();

                int min = Math.Min(Math.Min(a, b), Math.Min(c, d));
                return min;
            }

            int start = _nodes.Count;
            _nodes.Add(default);
            _nodes.Add(default);
            _nodes.Add(default);
            _nodes.Add(default);
            return start;
        }

        private void EnsureNodeCapacity(int index)
        {
            while (_nodes.Count <= index)
                _nodes.Add(default);
        }

        // --------------------------------------------------
        // Hierarchical Interface
        // --------------------------------------------------

        public QuadNodeInfo GetNode(int nodeIndex)
        {
            ValidateNodeIndex(nodeIndex);

            var n = _nodes[nodeIndex];

            return new QuadNodeInfo
            {
                X = n.X,
                Y = n.Y,
                Size = n.Size,
                Level = n.Level,
                IsLeaf = n.IsLeaf,
                IsActive = n.IsActive,
                ChildIndex = n.ChildIndex,
                TileSetId = n.TileSetId,
                TileIndex = n.TileIndex,
                Rotation = n.Rotation
            };
        }

        public IEnumerable<int> GetLeafIndices()
        {
            for (int i = 0; i < _nodes.Count; i++)
            {
                if (_nodes[i].IsActive && _nodes[i].IsLeaf)
                    yield return i;
            }
        }

        public void SetTileByNode(int nodeIndex, int tileSetId, int tileIndex, int rotation)
        {
            ValidateNodeIndex(nodeIndex);

            var node = _nodes[nodeIndex];

            if (!node.IsActive || !node.IsLeaf)
                return;

            node.TileSetId = tileSetId;
            node.TileIndex = tileIndex;
            node.Rotation = rotation;

            _nodes[nodeIndex] = node;
        }

        // --------------------------------------------------
        // Grid Interface (Uniform Only)
        // --------------------------------------------------

        public int Width
        {
            get
            {
                EnsureUniform();
                return 1 << _uniformDepth;
            }
        }

        public int Height
        {
            get
            {
                EnsureUniform();
                return 1 << _uniformDepth;
            }
        }

        public bool IsValid(int x, int y)
        {
            if (!_isUniformDepth)
                return false;

            int res = 1 << _uniformDepth;
            return x >= 0 && y >= 0 && x < res && y < res;
        }

        public GridCell GetCell(int x, int y)
        {
            EnsureUniform();

            if (!IsValid(x, y))
                throw new ArgumentOutOfRangeException();

            int nodeIndex = TraverseToLeaf(x, y);

            var node = _nodes[nodeIndex];

            return new GridCell(x, y)
            {
                TileSetId = node.TileSetId,
                TileIndex = node.TileIndex,
                Rotation = node.Rotation
            };
        }

        public void SetTile(int x, int y, int tileSetId, int tileIndex, int rotation)
        {
            EnsureUniform();

            int nodeIndex = TraverseToLeaf(x, y);

            SetTileByNode(nodeIndex, tileSetId, tileIndex, rotation);
        }

        private int TraverseToLeaf(int x, int y)
        {
            int nodeIndex = 0;

            for (int level = _uniformDepth - 1; level >= 0; level--)
            {
                var node = _nodes[nodeIndex];

                if (node.IsLeaf)
                    return nodeIndex;

                int half = 1 << level;

                bool right = x >= half;
                bool top = y >= half;

                int childOffset =
                    (!right && !top) ? 0 :
                    ( right && !top) ? 1 :
                    (!right &&  top) ? 2 : 3;

                if (right) x -= half;
                if (top) y -= half;

                nodeIndex = node.ChildIndex + childOffset;
            }

            return nodeIndex;
        }

        // --------------------------------------------------

        private void RecalculateUniformState()
        {
            int? depth = null;
            bool uniform = true;

            for (int i = 0; i < _nodes.Count; i++)
            {
                var n = _nodes[i];
                if (!n.IsActive || !n.IsLeaf)
                    continue;

                if (depth == null)
                    depth = n.Level;
                else if (depth.Value != n.Level)
                {
                    uniform = false;
                    break;
                }
            }

            _isUniformDepth = uniform && depth.HasValue;
            _uniformDepth = depth ?? 0;
        }

        private void EnsureUniform()
        {
            if (!_isUniformDepth)
                throw new InvalidOperationException(
                    "QuadTreeTileMap is adaptive. IGridLayout not supported.");
        }

        private void ValidateNodeIndex(int index)
        {
            if (index < 0 || index >= _nodes.Count)
                throw new ArgumentOutOfRangeException(nameof(index));
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\QuadTree\QuadTreeTileMap.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCommandParser.cs ---

// TODO ROADMAP:
// [x] Parse text script into render instructions
// [x] Support RCT, ELP, PIE, BZR
// [ ] Add syntax validation UI feedback
// [ ] Add comment support with #
// [ ] Add error highlighting in inspector

using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Truchet
{
    internal static class TileCommandParser
    {
        public static List<TileRenderInstruction> Parse(string script)
        {
            var instructions = new List<TileRenderInstruction>();

            if (string.IsNullOrWhiteSpace(script))
                return instructions;

            string[] lines = script.Split('\n');

            for (int i = 0; i < lines.Length; i++)
            {
                string rawLine = lines[i];
                string line = rawLine.Trim();

                if (string.IsNullOrEmpty(line))
                    continue;

                if (line.StartsWith("//"))
                    continue;

                string[] tokens = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                string opcode = tokens[0].ToUpperInvariant();

                try
                {
                    switch (opcode)
                    {
                        case "RCT":
                            instructions.Add(ParseRectangle(tokens));
                            break;

                        case "ELP":
                            instructions.Add(ParseEllipse(tokens));
                            break;

                        case "PIE":
                            instructions.Add(ParsePie(tokens));
                            break;

                        case "BZR":
                            instructions.Add(ParseBezier(tokens));
                            break;

                        default:
                            Debug.LogWarning($"Unknown command '{opcode}' at line {i + 1}");
                            break;
                    }
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed parsing line {i + 1}: {line}\n{e.Message}");
                }
            }

            return instructions;
        }

        private static RectangleInstruction ParseRectangle(string[] t)
        {
            return new RectangleInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4]))
            };
        }

        private static EllipseInstruction ParseEllipse(string[] t)
        {
            return new EllipseInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4]))
            };
        }

        private static PieInstruction ParsePie(string[] t)
        {
            return new PieInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4])),
                StartAngle = ParseFloat(t[5]),
                SweepAngle = ParseFloat(t[6])
            };
        }

        private static BezierInstruction ParseBezier(string[] t)
        {
            return new BezierInstruction
            {
                P0 = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                P1 = new Vector2(ParseFloat(t[3]), ParseFloat(t[4])),
                P2 = new Vector2(ParseFloat(t[5]), ParseFloat(t[6])),
                P3 = new Vector2(ParseFloat(t[7]), ParseFloat(t[8])),
                Thickness = ParseFloat(t[9])
            };
        }

        private static float ParseFloat(string value)
        {
            return float.Parse(value, CultureInfo.InvariantCulture);
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCommandParser.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTextureCooker.cs ---

// TODO ROADMAP:
// [x] Unified logical→visual mapping
// [x] Winged 2x resolution support
// [x] Transparent outer margin for winged tiles
// [x] Explicit logical square fill
// [x] Base parity cooking (no baked inversion)
// [x] Centralized coordinate mapping
// [x] PNG saving
// [ ] Anti-aliasing (supersample or SDF)
// [ ] Parametric color support (non black/white)
// [ ] Texture atlas cooking
// [ ] GPU-based baking backend
// [ ] Editor preview window
// [ ] Batch cook multiple definitions
// [ ] Parity debug overlay mode

using UnityEngine;
using UnityEditor;
using System.IO;
using System.Collections.Generic;

namespace Truchet
{
    public static class TileTextureCooker
    {
        // Wing geometry invariants (do NOT expose to inspector)
        private const float WingScale = 0.5f;   // logical domain occupies center 50%
        private const float WingOffset = 0.25f; // 25% margin on each side

        // --------------------------------------------------
        // Public Entry
        // --------------------------------------------------

        public static Tile Cook(TileCookDefinition definition)
        {
            EnsureFolder(definition.OutputFolder);

            Texture2D texture = Rasterize(definition);

            string basePath = "Assets/" + definition.OutputFolder;

            string pngPath = Path.Combine(basePath, definition.name + ".png");
            string tilePath = Path.Combine(basePath, definition.name + "_Tile.asset");

            SavePNG(texture, pngPath);

            AssetDatabase.Refresh();

            Texture2D importedTexture =
                AssetDatabase.LoadAssetAtPath<Texture2D>(pngPath);

            Tile tile = ScriptableObject.CreateInstance<Tile>();
            tile.connectivityMask = definition.Topology.Mask;
            tile.texture = importedTexture;
            tile.IsWinged = definition.IsWinged;

            AssetDatabase.CreateAsset(tile, tilePath);
            AssetDatabase.SaveAssets();

            return tile;
        }

        // --------------------------------------------------
        // Rasterization
        // --------------------------------------------------

        private static Texture2D Rasterize(TileCookDefinition def)
        {
            int baseWidth = def.Width;
            int baseHeight = def.Height;

            bool winged = def.IsWinged;

            int texWidth = winged ? baseWidth * 2 : baseWidth;
            int texHeight = winged ? baseHeight * 2 : baseHeight;

            float scale = winged ? WingScale : 1f;
            float offset = winged ? WingOffset : 0f;

            Texture2D texture =
                new Texture2D(texWidth, texHeight, TextureFormat.RGBA32, false);

            Color[] pixels = new Color[texWidth * texHeight];

            // --- Clear background ---
            Color clear = winged
                ? new Color(0, 0, 0, 0)  // transparent margin
                : Color.white;           // regular tiles fill whole domain

            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = clear;

            // --- Base parity model ---
            // We ALWAYS cook base motif:
            // Logical square = white
            // Motif geometry = black
            // Runtime will handle inversion by level parity.

            Color logicalColor = Color.white;
            Color motifColor = Color.black;

            // --- Fill logical square (only for winged) ---
            if (winged)
            {
                FillLogicalSquare(pixels, texWidth, texHeight, logicalColor);
            }

            // --- Execute render commands ---
            List<TileRenderInstruction> instructions =
                TileCommandParser.Parse(def.CommandScript);

            foreach (var instruction in instructions)
            {
                switch (instruction)
                {
                    case RectangleInstruction rectangle:
                        RasterizeRectangle(rectangle, pixels, texWidth, texHeight, scale, offset, motifColor);
                        break;

                    case EllipseInstruction ellipse:
                        RasterizeEllipse(ellipse, pixels, texWidth, texHeight, scale, offset, motifColor);
                        break;

                    case PieInstruction pie:
                        RasterizePie(pie, pixels, texWidth, texHeight, scale, offset, motifColor);
                        break;

                    case BezierInstruction bezier:
                        RasterizeBezier(bezier, pixels, texWidth, texHeight, scale, offset, motifColor);
                        break;
                }
            }

            texture.SetPixels(pixels);
            texture.Apply();

            return texture;
        }

        // --------------------------------------------------
        // Logical → Pixel Mapping
        // --------------------------------------------------

        private static Vector2 MapLogical(
            Vector2 logical,
            int width,
            int height,
            float scale,
            float offset)
        {
            float x = (offset + logical.x * scale) * width;
            float y = (offset + logical.y * scale) * height;
            return new Vector2(x, y);
        }

        // --------------------------------------------------
        // Logical Square Fill
        // --------------------------------------------------

        private static void FillLogicalSquare(
            Color[] pixels,
            int width,
            int height,
            Color logicalColor)
        {
            int startX = Mathf.RoundToInt(width * WingOffset);
            int endX = Mathf.RoundToInt(width * (WingOffset + WingScale));

            int startY = Mathf.RoundToInt(height * WingOffset);
            int endY = Mathf.RoundToInt(height * (WingOffset + WingScale));

            for (int y = startY; y < endY; y++)
            {
                for (int x = startX; x < endX; x++)
                {
                    pixels[y * width + x] = logicalColor;
                }
            }
        }

        // --------------------------------------------------
        // Rasterizers
        // --------------------------------------------------

        private static void RasterizeRectangle(
            RectangleInstruction rect,
            Color[] pixels,
            int width,
            int height,
            float scale,
            float offset,
            Color motifColor)
        {
            Vector2 center = MapLogical(rect.Center, width, height, scale, offset);

            float sx = rect.Size.x * scale * width * 0.5f;
            float sy = rect.Size.y * scale * height * 0.5f;

            int cx = Mathf.RoundToInt(center.x);
            int cy = Mathf.RoundToInt(center.y);

            for (int y = (int)(cy - sy); y < (int)(cy + sy); y++)
            {
                if (y < 0 || y >= height) continue;

                for (int x = (int)(cx - sx); x < (int)(cx + sx); x++)
                {
                    if (x < 0 || x >= width) continue;

                    pixels[y * width + x] = motifColor;
                }
            }
        }

        private static void RasterizeEllipse(
            EllipseInstruction ellipse,
            Color[] pixels,
            int width,
            int height,
            float scale,
            float offset,
            Color motifColor)
        {
            Vector2 center = MapLogical(ellipse.Center, width, height, scale, offset);

            float rx = ellipse.Size.x * scale * width * 0.5f;
            float ry = ellipse.Size.y * scale * height * 0.5f;

            int cx = Mathf.RoundToInt(center.x);
            int cy = Mathf.RoundToInt(center.y);

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    float dx = (x - cx) / rx;
                    float dy = (y - cy) / ry;

                    if (dx * dx + dy * dy <= 1f)
                        pixels[y * width + x] = motifColor;
                }
            }
        }

        private static void RasterizePie(
            PieInstruction pie,
            Color[] pixels,
            int width,
            int height,
            float scale,
            float offset,
            Color motifColor)
        {
            Vector2 center = MapLogical(pie.Center, width, height, scale, offset);

            float rx = pie.Size.x * scale * width * 0.5f;
            float ry = pie.Size.y * scale * height * 0.5f;

            int cx = Mathf.RoundToInt(center.x);
            int cy = Mathf.RoundToInt(center.y);

            float start = pie.StartAngle;
            float end = start + pie.SweepAngle;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    float dx = x - cx;
                    float dy = y - cy;

                    float nx = dx / rx;
                    float ny = dy / ry;

                    if (nx * nx + ny * ny > 1f)
                        continue;

                    float angle = Mathf.Atan2(dy, dx) * Mathf.Rad2Deg;
                    if (angle < 0)
                        angle += 360f;

                    if (IsAngleWithin(angle, start, end))
                        pixels[y * width + x] = motifColor;
                }
            }
        }

        private static bool IsAngleWithin(float angle, float start, float end)
        {
            if (end < start)
                end += 360f;

            if (angle < start)
                angle += 360f;

            return angle >= start && angle <= end;
        }

        private static void RasterizeBezier(
            BezierInstruction bezier,
            Color[] pixels,
            int width,
            int height,
            float scale,
            float offset,
            Color motifColor)
        {
            const int segments = 32;

            Vector2 prevLogical = bezier.P0;

            for (int i = 1; i <= segments; i++)
            {
                float t = i / (float)segments;
                Vector2 currLogical = EvaluateBezier(bezier, t);

                Vector2 a = MapLogical(prevLogical, width, height, scale, offset);
                Vector2 b = MapLogical(currLogical, width, height, scale, offset);

                float radius = bezier.Thickness * scale * width * 0.5f;

                DrawThickLine(a, b, radius, pixels, width, height, motifColor);

                prevLogical = currLogical;
            }
        }

        private static Vector2 EvaluateBezier(BezierInstruction b, float t)
        {
            float u = 1f - t;

            return
                u * u * u * b.P0 +
                3f * u * u * t * b.P1 +
                3f * u * t * t * b.P2 +
                t * t * t * b.P3;
        }

        private static void DrawThickLine(
            Vector2 a,
            Vector2 b,
            float radius,
            Color[] pixels,
            int width,
            int height,
            Color motifColor)
        {
            int steps = 16;

            for (int i = 0; i <= steps; i++)
            {
                float t = i / (float)steps;
                Vector2 p = Vector2.Lerp(a, b, t);

                int cx = Mathf.RoundToInt(p.x);
                int cy = Mathf.RoundToInt(p.y);

                for (int y = (int)(cy - radius); y <= (int)(cy + radius); y++)
                {
                    if (y < 0 || y >= height) continue;

                    for (int x = (int)(cx - radius); x <= (int)(cx + radius); x++)
                    {
                        if (x < 0 || x >= width) continue;

                        float dx = x - cx;
                        float dy = y - cy;

                        if (dx * dx + dy * dy <= radius * radius)
                            pixels[y * width + x] = motifColor;
                    }
                }
            }
        }

        // --------------------------------------------------
        // IO Helpers
        // --------------------------------------------------

        private static void SavePNG(Texture2D texture, string path)
        {
            byte[] png = texture.EncodeToPNG();
            File.WriteAllBytes(path, png);
        }

        private static void EnsureFolder(string relativeFolder)
        {
            string fullPath = Path.Combine("Assets", relativeFolder);

            if (!AssetDatabase.IsValidFolder(fullPath))
            {
                string[] parts = relativeFolder.Split('/');
                string current = "Assets";

                foreach (string part in parts)
                {
                    string next = current + "/" + part;

                    if (!AssetDatabase.IsValidFolder(next))
                        AssetDatabase.CreateFolder(current, part);

                    current = next;
                }
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTextureCooker.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\TileMapController.cs ---

// TODO ROADMAP:
// [x] Modifier-driven layout controller
// [x] Multi-TileSet registry
// [ ] Add runtime regeneration button
// [ ] Add deterministic seed support
// [ ] Add multiscale layout swap
// [ ] Add editor preview support

using UnityEngine;
using System.Collections.Generic;

namespace Truchet
{
    public class TileMapController  : MonoBehaviour
    {
        [SerializeField] private int _width = 8;
        [SerializeField] private int _height = 8;
        [SerializeField] private int _tileResolution = 256;
        [SerializeField] private Renderer _targetRenderer;
        [SerializeField] private bool _debugLines;

        private void Start()
        {
            RegularGridTileMap map =
                new RegularGridTileMap(_width, _height);

            TileMapModifier[] modifiers =
                GetComponents<TileMapModifier>();

            List<TileSet> tileSets = new List<TileSet>();

            // Build registry
            for (int i = 0; i < modifiers.Length; i++)
            {
                var mod = modifiers[i];

                if (mod.TileSet == null)
                    continue;

                mod.TileSetId = tileSets.Count;
                tileSets.Add(mod.TileSet);
            }

            // Apply modifiers
            foreach (var mod in modifiers)
            {
                if (mod.enabled)
                    mod.Apply(map);
            }

            TextureGridRenderer renderer =
                new TextureGridRenderer(_tileResolution);

            Texture2D result =
                renderer.Render(map, tileSets.ToArray(), _debugLines);

            _targetRenderer.material.mainTexture = result;
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\TileMapController.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\TextureGridRenderer.cs ---

// TODO ROADMAP:
// [x] CPU texture compositing renderer
// [x] Multi-TileSet support
// [ ] Add dirty-region updates
// [ ] Add chunked rendering
// [ ] Add GPU backend swap
// [ ] Add multiscale support
// [ ] Add tile caching

using UnityEngine;

namespace Truchet
{
    public class TextureGridRenderer
    {
        private readonly int _tileResolution;

        public TextureGridRenderer(int tileResolution)
        {
            _tileResolution = tileResolution;
        }

        public Texture2D Render(IGridLayout layout, TileSet[] tileSets, bool debugLines)
        {
            int width = layout.Width * _tileResolution;
            int height = layout.Height * _tileResolution;

            Texture2D output =
                new Texture2D(width, height, TextureFormat.RGBA32, false);

            Color[] pixels = new Color[width * height];

            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = Color.white;

            for (int y = 0; y < layout.Height; y++)
            {
                for (int x = 0; x < layout.Width; x++)
                {
                    GridCell cell = layout.GetCell(x, y);

                    if (cell.TileSetId < 0 ||
                        cell.TileSetId >= tileSets.Length)
                        continue;

                    TileSet tileSet = tileSets[cell.TileSetId];

                    if (cell.TileIndex < 0 ||
                        cell.TileIndex >= tileSet.tiles.Length)
                        continue;

                    BlitTile(tileSet.tiles[cell.TileIndex],
                             pixels, width, x, y, cell.Rotation);
                    
                    if (debugLines)
                        DrawCellDebugLines(pixels, width, x, y);
                }
            }

            if (debugLines)
                DrawAxis(pixels, width, height);

            output.SetPixels(pixels);
            output.Apply();

            return output;
        }

        private void BlitTile(
            Tile tile,
            Color[] target,
            int targetWidth,
            int gridX,
            int gridY,
            int rotation)
        {
            if (tile == null || tile.texture == null)
                return;

            Color[] source = tile.texture.GetPixels();

            int startX = gridX * _tileResolution;
            int startY = gridY * _tileResolution;

            for (int y = 0; y < _tileResolution; y++)
            for (int x = 0; x < _tileResolution; x++)
            {
                int srcIndex = GetRotatedIndex(x, y, rotation);

                int tx = startX + x;
                int ty = startY + y;

                target[ty * targetWidth + tx] = source[srcIndex];
            }
        }

        private int GetRotatedIndex(int x, int y, int rotation)
        {
            switch (rotation % 4)
            {
                case 0: return y * _tileResolution + x;
                case 1: return (_tileResolution - 1 - x) * _tileResolution + y;
                case 2: return (_tileResolution - 1 - y) * _tileResolution +
                               (_tileResolution - 1 - x);
                case 3: return x * _tileResolution +
                               (_tileResolution - 1 - y);
                default: return y * _tileResolution + x;
            }
        }
        
        private void DrawAxis(Color[] pixels, int width, int height)
        {
            int size = Mathf.Min(32, width / 6);

            int originX = 4;
            int originY = 4;

            for (int i = 0; i < size; i++)
            {
                int x = originX + i;
                int y = originY;

                if (x >= 0 && x < width && y >= 0 && y < height)
                    pixels[y * width + x] = Color.red;
            }

            for (int i = 0; i < size; i++)
            {
                int x = originX;
                int y = originY + i;

                if (x >= 0 && x < width && y >= 0 && y < height)
                    pixels[y * width + x] = Color.green;
            }
        }
        
        private void DrawCellDebugLines(
            Color[] pixels,
            int targetWidth,
            int gridX,
            int gridY)
        {
            int startX = gridX * _tileResolution;
            int startY = gridY * _tileResolution;

            int rightX = startX + _tileResolution - 1;
            int bottomY = startY + _tileResolution - 1;

            for (int y = startY; y < startY + _tileResolution; y++)
                pixels[y * targetWidth + rightX] = Color.green;

            for (int x = startX; x < startX + _tileResolution; x++)
                pixels[bottomY * targetWidth + x] = Color.green;
        }

    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\TextureGridRenderer.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\IGridLayout.cs ---

// TODO ROADMAP:
// [x] Define grid abstraction interface
// [ ] Add coordinate helpers
// [ ] Add neighbor query helpers
// [ ] Add bounds validation helpers
// [ ] Add serialization support if needed

using UnityEngine;

namespace Truchet
{
    /// <summary>
    /// Pure topology abstraction.
    /// Defines spatial indexing without rendering concerns.
    /// </summary>
    public interface IGridLayout
    {
        int Width { get; }
        int Height { get; }

        bool IsValid(int x, int y);

        GridCell GetCell(int x, int y);
    }
}


// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\IGridLayout.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\readme.md ---

# Truchet Tiles -- Multiscale & Winged Rendering System

## Overview

This module provides a scalable tile generation and rendering system
designed for:

-   Efficient GPU-driven rendering
-   True hierarchical QuadTree (not flat list)
-   Efficient subdivision logic
-   Clean data-oriented structures
-   Designed for large tile counts
-   Deterministic rebuild behavior
-   Editor-time tile baking pipeline
-   Support for both multiscale winged tiles and regular grids

The system is divided into two primary layers:

1.  Editor-time Tile Cooking
2.  Runtime Placement & Rendering

------------------------------------------------------------------------

# Winged Tile Definition

The direct method uses the "winged" tiles illustrated in Figure 3 of the
original paper.

A winged tile consists of:

-   The content of the tile inside a square boundary
-   "Wings" that extend outside the square to complete the motif
-   The square boundary is conceptual; wings intentionally exceed it
-   The gray background often shown in diagrams is not part of the tile
-   Wing shapes are arbitrary but stylistically consistent within a
    motif set

This allows seamless multiscale composition while maintaining visual
continuity across boundaries.

------------------------------------------------------------------------

# Editor-Time Tile Cooking

## Purpose

Prepare tile assets once, use many times at runtime.

## Pipeline

TileCookDefinition (ScriptableObject) → Command Script (DSL) →
TileCommandParser → TileRenderInstructions → TileTextureCooker → Tile
(Texture + Connectivity)

## Command DSL Example

ELP 0.5 1 0.2 0.2\
ELP 1 0.5 0.2 0.2\
BZR 0.5 1 0.5 0.75 0.75 0.5 1 0.5 0.15

Supported primitives:

-   RCT -- Rectangle
-   ELP -- Ellipse
-   PIE -- Pie slice
-   BZR -- Cubic Bezier with thickness

This enables:

-   Winged tiles
-   Classic Truchet tiles
-   Arbitrary motifs
-   Future SDF export
-   GPU baking in future

------------------------------------------------------------------------

# Runtime Architecture

Runtime does NOT generate textures.

Runtime consumes baked tiles and focuses on:

-   Placement
-   Subdivision
-   Transform generation
-   GPU rendering

------------------------------------------------------------------------

# Core Runtime Data Model

``` csharp
struct TileInstance
{
    public float4x4 transform;
    public int motifIndex;
    public int level;
}
```

Design rationale:

-   transform → world transform
-   motifIndex → index into TileSet
-   level → subdivision depth / parity / LOD

No per-instance texture references. GPU-friendly. Burst-compatible.

------------------------------------------------------------------------

# Placement Modes

## 1) Regular Grid Mode

-   Fixed cell size
-   No subdivision
-   Uniform transform scale
-   Ideal for deterministic tiling
-   Complexity: O(n)

## 2) Hierarchical QuadTree Mode

True tree, not flat list.

``` csharp
struct QuadNode
{
    public float2 position;
    public float size;
    public int level;
    public bool isLeaf;
    public int childIndex;
}
```

Characteristics:

-   Depth-based subdivision
-   Probabilistic subdivision
-   View-dependent subdivision (future)
-   LOD-aware rendering

Worst-case: O(4\^D)\
Practical: O(n) where n = number of leaf tiles

------------------------------------------------------------------------

# Winged Mode Support

Winged tiles are:

-   Baked at editor time
-   Texture-based at runtime
-   Compatible with both Regular Grid and QuadTree modes

Multiscale effect:

scale = 1 / (2\^level)

Tile cooker supports winged motifs via Bezier-based command DSL. Runtime
supports winged mode by respecting over-boundary motif geometry and
level scaling.

------------------------------------------------------------------------

# GPU Rendering Strategy

Primary target:

Graphics.DrawMeshInstancedIndirect

Per-instance data:

-   Transform matrix
-   Motif index
-   Level

Motif storage options:

A)  Single quad mesh + procedural shader (preferred)\
B)  Texture array atlas

------------------------------------------------------------------------

# Optimization Roadmap

## Rendering

-   Switch fully to indirect instancing
-   StructuredBuffer for TileInstance
-   Frustum culling per QuadNode
-   Shader-based motif logic

## Memory

-   Compress transform to float3x2
-   Half precision where possible
-   NativeList usage

## Subdivision

-   Burst job-based QuadTree
-   View-dependent subdivision
-   Deterministic per-node seeds

## Shader

-   Branchless parity logic
-   SDF-based winged motifs
-   Animated motif support

------------------------------------------------------------------------

# Design Philosophy

1.  Store transforms, not geometry.
2.  Bake visuals, not logic.
3.  Separate placement from rendering.
4.  Push work to GPU.
5.  Keep CPU memory linear.
6.  Avoid per-frame allocations.
7.  Design for 100k+ tiles.



// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\readme.md ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\QuadTree\QuadTreeTileMap-readme.md ---

# QuadTreeTileMap --- Architecture & Design Specification

## Overview

QuadTreeTileMap is a mutable hierarchical spatial container supporting
both:

-   Uniform grid access (Mode A)
-   Adaptive hierarchical access (Mode B)

It is designed to support: - Deterministic procedural generation -
Runtime structural mutation (subdivide / collapse) - Designer patch
workflows - Modifier-driven content changes - Future winged multiscale
rendering

The TileMap is strictly a container. It does not generate content
automatically. All generation logic is handled by modifiers.

------------------------------------------------------------------------

# Core Architectural Principles

1.  Stable Node Identity\
2.  Deterministic Structural Behavior\
3.  Canonical Child Ordering\
4.  Strict Mode Separation\
5.  No Hidden Side Effects\
6.  Spatial Traversal over Morton Encoding\
7.  Modifiers Own Content Generation

------------------------------------------------------------------------

# Interfaces

QuadTreeTileMap implements:

-   IGridLayout (Mode A only)
-   IHierarchicalTileLayout (always available)

------------------------------------------------------------------------

# Modes

## Mode A --- Uniform Depth (Grid Compatible)

Valid only if:

All active leaves share the same Level.

When valid:

-   Width = Height = 2\^depth
-   Spatial traversal resolves (x, y)
-   IGridLayout is fully supported

If not uniform:

-   IGridLayout methods throw InvalidOperationException

------------------------------------------------------------------------

## Mode B --- Adaptive Hierarchical Mode

-   Leaves may exist at mixed levels
-   IGridLayout is invalid
-   IHierarchicalTileLayout remains fully usable

------------------------------------------------------------------------

# Canonical Child Ordering

Child indices are permanently defined as:

```
  2   3
  --- ---
  0   1
```

0 = bottom-left\
1 = bottom-right\
2 = top-left\
3 = top-right

This ordering must never change.

Collapse behavior depends on this ordering.

------------------------------------------------------------------------

# Node Structure

Each node contains:

-   X, Y (spatial origin)
-   Size
-   Level
-   IsLeaf
-   IsActive
-   ChildIndex
-   TileSetId
-   TileIndex
-   Rotation

Inactive nodes retain their data.

Nodes are never physically removed from memory.

------------------------------------------------------------------------

# Stable Node Indices

-   Node indices never shift.
-   Collapse marks children inactive.
-   Subdivision may reuse indices from a free-list.
-   External systems (patch, modifiers) may safely store node indices.

------------------------------------------------------------------------

# Subdivision Rules

When Subdivide(node):

-   Only valid if node is a leaf.
-   4 children are created.
-   Children inherit parent tile values.
-   Parent becomes non-leaf.
-   Uniform state is recalculated.

------------------------------------------------------------------------

# Collapse Rules

When Collapse(node):

-   Only valid if node is non-leaf.
-   Parent tile becomes child\[0\] tile.
-   Children are marked inactive.
-   Children retain stored tile data.
-   Uniform state is recalculated.

No automatic merging heuristics exist.

------------------------------------------------------------------------

# Uniform Detection

Uniform mode is valid when:

All active leaves have identical Level.

This is recalculated after every structural mutation.

------------------------------------------------------------------------

# Spatial Traversal

Grid access uses spatial traversal:

-   Start at root
-   Descend by quadrant selection
-   Resolve leaf in O(depth)

Morton indexing is intentionally NOT used.

Reason:

-   Preserves structural semantics
-   Works for adaptive trees
-   Safer for mutable systems
-   Easier for patch workflows

------------------------------------------------------------------------

# Determinism

-   QuadTreeTileMap does not auto-generate randomness.

-   If random subdivision is implemented, it must use:

    nodeSeed = Hash(globalSeed, node.Level, node.X, node.Y)

-   No UnityEngine.Random allowed.

Tree structure changes only through explicit calls.

------------------------------------------------------------------------

# Mutability

Allowed operations:

-   Subdivide(node)
-   Collapse(node)
-   SetTileByNode(node)
-   SetTile(x,y) (uniform mode only)

Structure never rebuilds implicitly.

------------------------------------------------------------------------

# Modifier Responsibility

Modifiers:

-   Own procedural generation
-   Own random behavior (seeded)
-   Mutate tile content
-   Do not own structure unless explicitly intended

TileMap is a passive container.

------------------------------------------------------------------------

# Rendering Implications

Grid renderer operates in Mode A.

Future winged multiscale renderer will use:

-   IHierarchicalTileLayout
-   Node spatial data
-   Level-based scaling

------------------------------------------------------------------------

# Non-Goals

QuadTreeTileMap will NOT:

-   Auto-balance structure
-   Auto-generate content
-   Implicitly rebuild on seed change
-   Hide invalid grid access in adaptive mode

------------------------------------------------------------------------

# Future Extensions

-   Adaptive view-dependent LOD
-   Burst-compatible node storage
-   GPU transform streaming
-   Constraint-based subdivision modifiers

------------------------------------------------------------------------

# Summary

QuadTreeTileMap is:

-   Deterministic
-   Mutable
-   Designer-safe
-   Dual-interface compliant
-   Strictly structured
-   Future-proof for multiscale winged rendering


// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\QuadTree\QuadTreeTileMap-readme.md ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookerEditor.cs ---

// TODO ROADMAP:
// [x] Add cook button
// [x] Remove folder popup
// [ ] Add preview panel
// [ ] Add batch cook window
// [ ] Add atlas cook option

using UnityEditor;
using UnityEngine;

namespace Truchet
{
    [CustomEditor(typeof(TileCookDefinition))]
    public class TileCookerEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            var def = (TileCookDefinition)target;

            GUILayout.Space(10);

            if (GUILayout.Button("Cook Tile"))
            {
                TileTextureCooker.Cook(def);
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookerEditor.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\TileMapModifier.cs ---

// TODO ROADMAP:
// [x] Base class for stackable layout modifiers
// [x] TileSet ownership per modifier
// [ ] Add execution order override support
// [ ] Add enable/disable runtime toggle
// [ ] Add priority system
// [ ] Add multiscale compatibility

using UnityEngine;

namespace Truchet
{
    public abstract class TileMapModifier : MonoBehaviour
    {
        [SerializeField] protected TileSet _tileSet;

        internal int TileSetId { get; set; }

        public TileSet TileSet => _tileSet;

        public abstract void Apply(RegularGridTileMap map);
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\TileMapModifier.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\RegularGridTileMap.cs ---

// TODO ROADMAP:
// [x] Basic rectangular grid implementation
// [x] Renamed from RegularGridLayout
// [ ] Add neighbor query API
// [ ] Add iteration helpers
// [ ] Add deterministic fill utilities
// [ ] Add resize support

namespace Truchet
{
    public class RegularGridTileMap : IGridLayout
    {
        private readonly GridCell[,] _cells;

        public int Width { get; }
        public int Height { get; }

        public RegularGridTileMap(int width, int height)
        {
            Width = width;
            Height = height;

            _cells = new GridCell[width, height];

            for (int y = 0; y < height; y++)
            for (int x = 0; x < width; x++)
                _cells[x, y] = new GridCell(x, y);
        }

        public bool IsValid(int x, int y)
        {
            return x >= 0 && y >= 0 && x < Width && y < Height;
        }

        public GridCell GetCell(int x, int y)
        {
            if (!IsValid(x, y))
                throw new System.ArgumentOutOfRangeException();

            return _cells[x, y];
        }

        public void SetTile(int x, int y, int tileSetId, int tileIndex, int rotation)
        {
            if (!IsValid(x, y))
                return;

            GridCell cell = _cells[x, y];
            cell.TileSetId = tileSetId;
            cell.TileIndex = tileIndex;
            cell.Rotation = rotation;

            _cells[x, y] = cell;
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\RegularGridTileMap.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\TileMapModifierRandom.cs ---

// TODO ROADMAP:
// [x] Component-based random layout modifier
// [x] Multi-TileSet support
// [ ] Add deterministic seed support
// [ ] Add weighted tile selection
// [ ] Add adjacency-aware randomization
// [ ] Add tile filtering
// [x] Allowed rotation index control

using UnityEngine;

namespace Truchet
{
    public class TileMapModifierRandom : TileMapModifier
    {
        [SerializeField] private int[] _allowedRotations = { 0, 1, 2, 3 };

        public override void Apply(RegularGridTileMap map)
        {
            if (!enabled)
                return;
            
            if (map == null || _tileSet == null || _tileSet.tiles == null)
                return;

            bool useCustomRotations =
                _allowedRotations != null && _allowedRotations.Length > 0;

            for (int y = 0; y < map.Height; y++)
            {
                for (int x = 0; x < map.Width; x++)
                {
                    int tileIndex = Random.Range(0, _tileSet.tiles.Length);

                    int rotation;

                    if (useCustomRotations)
                    {
                        int r = Random.Range(0, _allowedRotations.Length);
                        rotation = Mathf.Clamp(_allowedRotations[r], 0, 3);
                    }
                    else
                    {
                        rotation = Random.Range(0, 4);
                    }

                    map.SetTile(x, y, TileSetId, tileIndex, rotation);
                }
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\TileMapModifierRandom.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileRenderInstructions.cs ---

// TODO ROADMAP:
// [x] Polymorphic render instruction model
// [x] Rectangle, Ellipse, Pie, Bezier instructions
// [ ] Add LineInstruction
// [ ] Add PolygonInstruction
// [ ] Add GradientInstruction
// [ ] Add Anti-aliased rasterization support

using UnityEngine;

namespace Truchet
{
    internal abstract class TileRenderInstruction
    {
    }

    internal sealed class RectangleInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
    }

    internal sealed class EllipseInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
    }

    internal sealed class PieInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
        public float StartAngle;
        public float SweepAngle;
    }

    internal sealed class BezierInstruction : TileRenderInstruction
    {
        public Vector2 P0;
        public Vector2 P1;
        public Vector2 P2;
        public Vector2 P3;
        public float Thickness;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileRenderInstructions.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\Direction.cs ---

// TODO ROADMAP:
// [x] Direction enum
// [ ] Use the one from gamelib
// [ ] Add diagonal support
// [ ] Add vector conversion helpers

namespace Truchet
{
    public enum Direction
    {
        Right,
        Up,
        Left,
        Down
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\Direction.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileSet.cs ---

// TODO ROADMAP:
// [x] TileSet asset (collection of tiles)
// [ ] Add lookup by connectivity
// [ ] Add weighted lookup
// [ ] Add adjacency filtering helpers
// [ ] Add runtime dictionary cache

using UnityEngine;

namespace Truchet
{
    [CreateAssetMenu(
        fileName = "TileSet",
        menuName = "Truchet/Tiles/Tile Set",
        order = 1)]
    public class TileSet : ScriptableObject
    {
        public Tile[] tiles;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileSet.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\Tile.cs ---

// TODO ROADMAP:
// [x] Runtime tile asset (texture + connectivity)
// [x] PNG-based workflow
// [x] Rotation-aware connectivity helper
// [x] Winged flag
// [ ] Add normal map support
// [ ] Add SDF texture support
// [ ] Add metadata tags
// [ ] Add addressables support

using UnityEngine;

namespace Truchet
{
    [CreateAssetMenu(
        fileName = "Tile",
        menuName = "Truchet/Tiles/Tile",
        order = 0)]
    public class Tile : ScriptableObject
    {
        [Tooltip("NESW bitmask")]
        public int connectivityMask;

        public Texture2D texture;

        [Header("Winged Rendering")]
        public bool IsWinged;

        public string MarchingSquareApproximation;

        public int GetRotatedMask(int rotation)
        {
            return TileTopology.RotateMask(connectivityMask, rotation);
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\Tile.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\TileMapModifierDirectionPattern.cs ---

// TODO ROADMAP:
// [x] Direction pattern modifier
// [x] Multi-line rotation pattern
// [ ] Add validation warnings
// [ ] Add tile index strategy
// [ ] Add connectivity awareness

using NaughtyAttributes;
using UnityEngine;

namespace Truchet
{
    public class TileMapModifierDirectionPattern : TileMapModifier
    {
        [ResizableTextArea]
        [SerializeField] private string _rotationPattern;

        public override void Apply(RegularGridTileMap map)
        {
            if (!enabled)
                return;
            
            if (map == null || _tileSet == null || _tileSet.tiles == null)
                return;

            if (string.IsNullOrWhiteSpace(_rotationPattern))
                return;

            string[] rows = _rotationPattern
                .Replace("\r", "")
                .Split('\n');

            for (int y = 0; y < map.Height; y++)
            {
                if (rows.Length == 0)
                    break;

                string rowPattern = rows[y % rows.Length];

                if (string.IsNullOrEmpty(rowPattern))
                    continue;

                for (int x = 0; x < map.Width; x++)
                {
                    char c = rowPattern[x % rowPattern.Length];

                    int rotation = DirectionToRotation(c);

                    int tileIndex = x % _tileSet.tiles.Length;

                    map.SetTile(x, y, TileSetId, tileIndex, rotation);
                }
            }
        }

        private int DirectionToRotation(char c)
        {
            switch (char.ToUpperInvariant(c))
            {
                case 'L': return 0;
                case 'U': return 1;
                case 'R': return 2;
                case 'D': return 3;
                default: return 0;
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\LayoutModifiers\TileMapModifierDirectionPattern.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileTopology.cs ---

// TODO ROADMAP:
// [x] Simple NESW topology struct
// [x] Mask encoding
// [x] Rotation helper
// [ ] Add compatibility check
// [ ] Add neighbor matching helpers


namespace Truchet
{
    [System.Serializable]
    public struct TileTopology
    {
        public bool north;
        public bool east;
        public bool south;
        public bool west;

        /// <summary>
        /// Bitmask encoding:
        /// bit 0 → north
        /// bit 1 → east
        /// bit 2 → south
        /// bit 3 → west
        /// </summary>
        public int Mask =>
            (north ? 1 : 0) |
            (east  ? 2 : 0) |
            (south ? 4 : 0) |
            (west  ? 8 : 0);

        /// <summary>
        /// Rotates NESW mask clockwise by 90° steps.
        /// rotation: can be negative or greater than 3.
        /// </summary>
        public static int RotateMask(int mask, int rotation)
        {
            // Normalize rotation to 0..3
            rotation = ((rotation % 4) + 4) % 4;

            for (int i = 0; i < rotation; i++)
            {
                int north = (mask & 1) != 0 ? 1 : 0;
                int east  = (mask & 2) != 0 ? 1 : 0;
                int south = (mask & 4) != 0 ? 1 : 0;
                int west  = (mask & 8) != 0 ? 1 : 0;

                mask =
                    (west  << 0) | // new north
                    (north << 1) | // new east
                    (east  << 2) | // new south
                    (south << 3);  // new west
            }

            return mask;
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileTopology.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\QuadTree\QuadNodeInfo.cs ---

// TODO ROADMAP:
// [x] Quad node info struct
// [ ] Add transform helper
// [ ] Add world-space conversion helpers

namespace Truchet
{
    public struct QuadNodeInfo
    {
        public float X;
        public float Y;
        public float Size;
        public int Level;

        public bool IsLeaf;
        public bool IsActive;

        public int ChildIndex;

        public int TileSetId;
        public int TileIndex;
        public int Rotation;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\QuadTree\QuadNodeInfo.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\IHierarchicalTileLayout.cs ---

// TODO ROADMAP:
// [x] Hierarchical tile layout interface
// [ ] Add neighbor query helpers
// [ ] Add transform extraction helpers
// [ ] Add bulk iteration API

using System.Collections.Generic;

namespace Truchet
{
    public interface IHierarchicalTileLayout
    {
        int NodeCount { get; }
        int LeafCount { get; }

        QuadNodeInfo GetNode(int nodeIndex);
        IEnumerable<int> GetLeafIndices();

        void Subdivide(int nodeIndex);
        void Collapse(int nodeIndex);

        void SetTileByNode(int nodeIndex, int tileSetId, int tileIndex, int rotation);

        bool IsUniformDepth { get; }
        int UniformDepth { get; }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Grid\IHierarchicalTileLayout.cs ---


--------------------------------------------------
// --- Prompt ---

You are continuing development of an existing module.

Context:
- I provide a blob of files representing the current implementation state.
- The module already has working functionality.
- There is an existing architecture and design philosophy (see included markdown).
- Your task is to analyze and continue structured development.

Your responsibilities:

1. Code Review (Concise)
   - Evaluate structure, architecture, cohesion, and clarity.
   - Identify architectural weaknesses, coupling issues, or scalability risks.
   - Do NOT rewrite everything unless necessary.
   - Be precise and technical.

2. Architecture Validation
   - Validate alignment with the design markdown and stated constraints.
   - Identify violations or future bottlenecks.

3. Roadmap Construction
   - Build a prioritized development roadmap.
   - Group features into phases (Foundation / Extension / Advanced).
   - Focus on extensibility and long-term scalability.

4. Step-by-Step Implementation Mode
   - Provide ONE implementation step per message.
   - Each step must:
        • Be small and focused
        • Include reasoning
        • Include full code listing for changed files
        • Start each file/class with a TODO roadmap block
   - After each step, stop and ask for confirmation before continuing.

5. Development Constraints
   - Favor modularity and separation of concerns.
   - Avoid hidden coupling between systems.
   - Avoid refresh-loop or asset pipeline side effects.
   - Keep deterministic rebuild behavior.
   - Design for future expansion (animation, metadata, addressables, etc.).

6. Best Practices
   - Recommend architectural patterns where applicable.
   - Suggest refactors only if they improve extensibility.
   - Avoid premature optimization.

7. Communication Style
   - Be concise.
   - No filler.
   - No long explanations unless necessary.
   - High signal, low noise.
   - Assume senior-level development context.

8. Markdown Awareness
   - Respect documented architecture rules.
   - Do not contradict design constraints.
   - If you suggest deviation, justify clearly.

Important:
This is an ongoing development session.
Treat the current code as a living module, not a prototype.
Build on it incrementally.