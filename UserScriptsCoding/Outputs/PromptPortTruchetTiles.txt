// --- Source Blob ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTextureCooker.cs ---

// TODO ROADMAP:
// [x] Rasterize tile commands into texture
// [x] Create Tile asset
// [x] Use output folder from definition
// [ ] Add anti-aliasing
// [ ] Add GPU RenderTexture backend
// [ ] Add atlas cooking
// [ ] Add batch cooking

using UnityEngine;
using UnityEditor;
using System.IO;
using Truchet.Tiles;

namespace Truchet.TileCooking
{
    public static class TileTextureCooker
    {
        public static Tile Cook(TileCookDefinition definition)
        {
            EnsureFolder(definition.outputFolder);

            var texture = Rasterize(definition);

            string basePath = "Assets/" + definition.outputFolder;

            string texturePath = Path.Combine(basePath, definition.name + "_Tex.asset");
            string tilePath    = Path.Combine(basePath, definition.name + "_Tile.asset");

            AssetDatabase.CreateAsset(texture, texturePath);

            var tile = ScriptableObject.CreateInstance<Tile>();
            tile.connectivityMask = definition.topology.Mask;
            tile.texture = texture;

            AssetDatabase.CreateAsset(tile, tilePath);
            AssetDatabase.SaveAssets();

            return tile;
        }

        private static void EnsureFolder(string relativeFolder)
        {
            string fullPath = Path.Combine("Assets", relativeFolder);

            if (!AssetDatabase.IsValidFolder(fullPath))
            {
                string[] parts = relativeFolder.Split('/');
                string current = "Assets";

                foreach (var part in parts)
                {
                    string next = current + "/" + part;

                    if (!AssetDatabase.IsValidFolder(next))
                        AssetDatabase.CreateFolder(current, part);

                    current = next;
                }
            }
        }

        private static Texture2D Rasterize(TileCookDefinition def)
        {
            int w = def.width;
            int h = def.height;

            var tex = new Texture2D(w, h, TextureFormat.RGBA32, false);
            var pixels = new Color[w * h];

            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = Color.white;

            foreach (var cmd in def.commands)
                RasterizeCommand(pixels, w, h, cmd);

            tex.SetPixels(pixels);
            tex.Apply();

            return tex;
        }

        private static void RasterizeCommand(Color[] pixels, int w, int h, TileRenderCommand cmd)
        {
            if (cmd.type != TilePrimitiveType.Rectangle)
                return;

            int cx = Mathf.RoundToInt(cmd.center.x * w);
            int cy = Mathf.RoundToInt(cmd.center.y * h);

            int sx = Mathf.RoundToInt(cmd.size.x * w * 0.5f);
            int sy = Mathf.RoundToInt(cmd.size.y * h * 0.5f);

            for (int y = cy - sy; y < cy + sy; y++)
            {
                if (y < 0 || y >= h) continue;

                for (int x = cx - sx; x < cx + sx; x++)
                {
                    if (x < 0 || x >= w) continue;

                    pixels[y * w + x] = cmd.primary ? Color.white : Color.black;
                }
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTextureCooker.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookDefinition.cs ---

using UnityEngine;

namespace Truchet.TileCooking
{
    [CreateAssetMenu(
        fileName = "TileCookDefinition",
        menuName = "Truchet/Tile Cooking/Tile Cook Definition",
        order = 0)]
    public class TileCookDefinition : ScriptableObject
    {
        [Header("Resolution")]
        public int Width = 256;
        public int Height = 256;

        [Header("Output Folder (relative to Assets/)")]
        public string OutputFolder = "Data/Tiles";

        [Header("Topology")]
        public TileTopology Topology;

        [Header("Command Script")]
        [TextArea(10, 40)]
        public string CommandScript;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookDefinition.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookerEditor.cs ---

// TODO ROADMAP:
// [x] Add cook button
// [x] Remove folder popup
// [ ] Add preview panel
// [ ] Add batch cook window
// [ ] Add atlas cook option

using UnityEditor;
using UnityEngine;

namespace Truchet.TileCooking
{
    [CustomEditor(typeof(TileCookDefinition))]
    public class TileCookerEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            var def = (TileCookDefinition)target;

            GUILayout.Space(10);

            if (GUILayout.Button("Cook Tile"))
            {
                TileTextureCooker.Cook(def);
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookerEditor.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTopology.cs ---

// TODO ROADMAP:
// [x] Simple NESW topology struct
// [ ] Add helper methods
// [ ] Add rotation helpers
// [ ] Add compatibility check

using UnityEngine;

namespace Truchet.TileCooking
{
    [System.Serializable]
    public struct TileTopology
    {
        public bool north;
        public bool east;
        public bool south;
        public bool west;

        public int Mask =>
            (north ? 1 : 0) |
            (east  ? 2 : 0) |
            (south ? 4 : 0) |
            (west  ? 8 : 0);
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTopology.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileSet.cs ---

// TODO ROADMAP:
// [x] TileSet asset (collection of tiles)
// [ ] Add lookup by connectivity
// [ ] Add weighted lookup
// [ ] Add adjacency filtering helpers
// [ ] Add runtime dictionary cache

using UnityEngine;

namespace Truchet.Tiles
{
    [CreateAssetMenu(
        fileName = "TileSet",
        menuName = "Truchet/Tiles/Tile Set",
        order = 1)]
    public class TileSet : ScriptableObject
    {
        public Tile[] tiles;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileSet.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileRenderInstructions.cs ---

// TODO ROADMAP:
// [x] Polymorphic render instruction model
// [x] Rectangle, Ellipse, Pie, Bezier instructions
// [ ] Add LineInstruction
// [ ] Add PolygonInstruction
// [ ] Add GradientInstruction
// [ ] Add Anti-aliased rasterization support

using UnityEngine;

namespace Truchet.TileCooking
{
    internal abstract class TileRenderInstruction
    {
    }

    internal sealed class RectangleInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
    }

    internal sealed class EllipseInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
    }

    internal sealed class PieInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
        public float StartAngle;
        public float SweepAngle;
    }

    internal sealed class BezierInstruction : TileRenderInstruction
    {
        public Vector2 P0;
        public Vector2 P1;
        public Vector2 P2;
        public Vector2 P3;
        public float Thickness;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileRenderInstructions.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCommandParser.cs ---

// TODO ROADMAP:
// [x] Parse text script into render instructions
// [x] Support RCT, ELP, PIE, BZR
// [ ] Add syntax validation UI feedback
// [ ] Add comment support with #
// [ ] Add error highlighting in inspector

using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Truchet.TileCooking
{
    internal static class TileCommandParser
    {
        public static List<TileRenderInstruction> Parse(string script)
        {
            var instructions = new List<TileRenderInstruction>();

            if (string.IsNullOrWhiteSpace(script))
                return instructions;

            string[] lines = script.Split('\n');

            for (int i = 0; i < lines.Length; i++)
            {
                string rawLine = lines[i];
                string line = rawLine.Trim();

                if (string.IsNullOrEmpty(line))
                    continue;

                if (line.StartsWith("//"))
                    continue;

                string[] tokens = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                string opcode = tokens[0].ToUpperInvariant();

                try
                {
                    switch (opcode)
                    {
                        case "RCT":
                            instructions.Add(ParseRectangle(tokens));
                            break;

                        case "ELP":
                            instructions.Add(ParseEllipse(tokens));
                            break;

                        case "PIE":
                            instructions.Add(ParsePie(tokens));
                            break;

                        case "BZR":
                            instructions.Add(ParseBezier(tokens));
                            break;

                        default:
                            Debug.LogWarning($"Unknown command '{opcode}' at line {i + 1}");
                            break;
                    }
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed parsing line {i + 1}: {line}\n{e.Message}");
                }
            }

            return instructions;
        }

        private static RectangleInstruction ParseRectangle(string[] t)
        {
            return new RectangleInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4]))
            };
        }

        private static EllipseInstruction ParseEllipse(string[] t)
        {
            return new EllipseInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4]))
            };
        }

        private static PieInstruction ParsePie(string[] t)
        {
            return new PieInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4])),
                StartAngle = ParseFloat(t[5]),
                SweepAngle = ParseFloat(t[6])
            };
        }

        private static BezierInstruction ParseBezier(string[] t)
        {
            return new BezierInstruction
            {
                P0 = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                P1 = new Vector2(ParseFloat(t[3]), ParseFloat(t[4])),
                P2 = new Vector2(ParseFloat(t[5]), ParseFloat(t[6])),
                P3 = new Vector2(ParseFloat(t[7]), ParseFloat(t[8])),
                Thickness = ParseFloat(t[9])
            };
        }

        private static float ParseFloat(string value)
        {
            return float.Parse(value, CultureInfo.InvariantCulture);
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCommandParser.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\Tile.cs ---

// TODO ROADMAP:
// [x] Runtime tile asset (texture + connectivity)
// [ ] Add normal map support
// [ ] Add SDF texture support
// [ ] Add GPU index support
// [ ] Add metadata tags

using UnityEngine;

namespace Truchet.Tiles
{
    [CreateAssetMenu(
        fileName = "Tile",
        menuName = "Truchet/Tiles/Tile",
        order = 0)]
    public class Tile : ScriptableObject
    {
        [Tooltip("NESW bitmask")]
        public int connectivityMask;

        public Texture2D texture;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\Tile.cs ---


--------------------------------------------------
// --- Prompt ---

You are continuing development of an existing module.

Context:
- I provide a blob of files representing the current implementation state.
- The module already has working functionality.
- There is an existing architecture and design philosophy (see included markdown).
- Your task is to analyze and continue structured development.

Your responsibilities:

1. Code Review (Concise)
   - Evaluate structure, architecture, cohesion, and clarity.
   - Identify architectural weaknesses, coupling issues, or scalability risks.
   - Do NOT rewrite everything unless necessary.
   - Be precise and technical.

2. Architecture Validation
   - Validate alignment with the design markdown and stated constraints.
   - Identify violations or future bottlenecks.

3. Roadmap Construction
   - Build a prioritized development roadmap.
   - Group features into phases (Foundation / Extension / Advanced).
   - Focus on extensibility and long-term scalability.

4. Step-by-Step Implementation Mode
   - Provide ONE implementation step per message.
   - Each step must:
        • Be small and focused
        • Include reasoning
        • Include full code listing for changed files
        • Start each file/class with a TODO roadmap block
   - After each step, stop and ask for confirmation before continuing.

5. Development Constraints
   - Favor modularity and separation of concerns.
   - Avoid hidden coupling between systems.
   - Avoid refresh-loop or asset pipeline side effects.
   - Keep deterministic rebuild behavior.
   - Design for future expansion (animation, metadata, addressables, etc.).

6. Best Practices
   - Recommend architectural patterns where applicable.
   - Suggest refactors only if they improve extensibility.
   - Avoid premature optimization.

7. Communication Style
   - Be concise.
   - No filler.
   - No long explanations unless necessary.
   - High signal, low noise.
   - Assume senior-level development context.

8. Markdown Awareness
   - Respect documented architecture rules.
   - Do not contradict design constraints.
   - If you suggest deviation, justify clearly.

Important:
This is an ongoing development session.
Treat the current code as a living module, not a prototype.
Build on it incrementally.