// --- Source Blob ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookDefinition.cs ---

using UnityEngine;

namespace Truchet.TileCooking
{
    [CreateAssetMenu(
        fileName = "TileCookDefinition",
        menuName = "Truchet/Tile Cooking/Tile Cook Definition",
        order = 0)]
    public class TileCookDefinition : ScriptableObject
    {
        [Header("Resolution")]
        public int Width = 256;
        public int Height = 256;

        [Header("Winged Mode")]
        public bool IsWinged;

        public bool IsInversed;
        

        [Header("Output Folder (relative to Assets/)")]
        public string OutputFolder = "Core/Textures/Tiles";

        [Header("Topology")]
        public TileTopology Topology;

        [Header("Command Script")]
        [TextArea(10, 40)]
        public string CommandScript;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookDefinition.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCommandParser.cs ---

// TODO ROADMAP:
// [x] Parse text script into render instructions
// [x] Support RCT, ELP, PIE, BZR
// [ ] Add syntax validation UI feedback
// [ ] Add comment support with #
// [ ] Add error highlighting in inspector

using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Truchet.TileCooking
{
    internal static class TileCommandParser
    {
        public static List<TileRenderInstruction> Parse(string script)
        {
            var instructions = new List<TileRenderInstruction>();

            if (string.IsNullOrWhiteSpace(script))
                return instructions;

            string[] lines = script.Split('\n');

            for (int i = 0; i < lines.Length; i++)
            {
                string rawLine = lines[i];
                string line = rawLine.Trim();

                if (string.IsNullOrEmpty(line))
                    continue;

                if (line.StartsWith("//"))
                    continue;

                string[] tokens = line.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                string opcode = tokens[0].ToUpperInvariant();

                try
                {
                    switch (opcode)
                    {
                        case "RCT":
                            instructions.Add(ParseRectangle(tokens));
                            break;

                        case "ELP":
                            instructions.Add(ParseEllipse(tokens));
                            break;

                        case "PIE":
                            instructions.Add(ParsePie(tokens));
                            break;

                        case "BZR":
                            instructions.Add(ParseBezier(tokens));
                            break;

                        default:
                            Debug.LogWarning($"Unknown command '{opcode}' at line {i + 1}");
                            break;
                    }
                }
                catch (Exception e)
                {
                    Debug.LogError($"Failed parsing line {i + 1}: {line}\n{e.Message}");
                }
            }

            return instructions;
        }

        private static RectangleInstruction ParseRectangle(string[] t)
        {
            return new RectangleInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4]))
            };
        }

        private static EllipseInstruction ParseEllipse(string[] t)
        {
            return new EllipseInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4]))
            };
        }

        private static PieInstruction ParsePie(string[] t)
        {
            return new PieInstruction
            {
                Center = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                Size = new Vector2(ParseFloat(t[3]), ParseFloat(t[4])),
                StartAngle = ParseFloat(t[5]),
                SweepAngle = ParseFloat(t[6])
            };
        }

        private static BezierInstruction ParseBezier(string[] t)
        {
            return new BezierInstruction
            {
                P0 = new Vector2(ParseFloat(t[1]), ParseFloat(t[2])),
                P1 = new Vector2(ParseFloat(t[3]), ParseFloat(t[4])),
                P2 = new Vector2(ParseFloat(t[5]), ParseFloat(t[6])),
                P3 = new Vector2(ParseFloat(t[7]), ParseFloat(t[8])),
                Thickness = ParseFloat(t[9])
            };
        }

        private static float ParseFloat(string value)
        {
            return float.Parse(value, CultureInfo.InvariantCulture);
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCommandParser.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileRenderInstructions.cs ---

// TODO ROADMAP:
// [x] Polymorphic render instruction model
// [x] Rectangle, Ellipse, Pie, Bezier instructions
// [ ] Add LineInstruction
// [ ] Add PolygonInstruction
// [ ] Add GradientInstruction
// [ ] Add Anti-aliased rasterization support

using UnityEngine;

namespace Truchet.TileCooking
{
    internal abstract class TileRenderInstruction
    {
    }

    internal sealed class RectangleInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
    }

    internal sealed class EllipseInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
    }

    internal sealed class PieInstruction : TileRenderInstruction
    {
        public Vector2 Center;
        public Vector2 Size;
        public float StartAngle;
        public float SweepAngle;
    }

    internal sealed class BezierInstruction : TileRenderInstruction
    {
        public Vector2 P0;
        public Vector2 P1;
        public Vector2 P2;
        public Vector2 P3;
        public float Thickness;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileRenderInstructions.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTextureCooker.cs ---

// TODO ROADMAP:
// [x] Parse command script
// [x] Polymorphic rasterization dispatch
// [x] Rectangle rasterization
// [ ] Ellipse rasterization
// [ ] Pie rasterization
// [ ] Bezier rasterization
// [ ] Anti-aliased rasterization
// [ ] GPU RenderTexture backend
// [ ] Atlas cooking
// [ ] Batch cooking

using UnityEngine;
using UnityEditor;
using System.IO;
using System.Collections.Generic;
using Truchet.Tiles;

namespace Truchet.TileCooking
{
    public static class TileTextureCooker
    {
        public static Tile Cook(TileCookDefinition definition)
        {
            EnsureFolder(definition.OutputFolder);

            Texture2D texture = Rasterize(definition);

            string basePath = "Assets/" + definition.OutputFolder;

            string texturePath = Path.Combine(basePath, definition.name + "_Tex.asset");
            string tilePath = Path.Combine(basePath, definition.name + "_Tile.asset");

            AssetDatabase.CreateAsset(texture, texturePath);

            Tile tile = ScriptableObject.CreateInstance<Tile>();
            tile.connectivityMask = definition.Topology.Mask;
            tile.texture = texture;

            AssetDatabase.CreateAsset(tile, tilePath);
            AssetDatabase.SaveAssets();

            return tile;
        }

        private static void EnsureFolder(string relativeFolder)
        {
            string fullPath = Path.Combine("Assets", relativeFolder);

            if (!AssetDatabase.IsValidFolder(fullPath))
            {
                string[] parts = relativeFolder.Split('/');
                string current = "Assets";

                foreach (string part in parts)
                {
                    string next = current + "/" + part;

                    if (!AssetDatabase.IsValidFolder(next))
                        AssetDatabase.CreateFolder(current, part);

                    current = next;
                }
            }
        }

        private static Texture2D Rasterize(TileCookDefinition def)
        {
            int width = def.Width;
            int height = def.Height;

            Texture2D texture = new Texture2D(width, height, TextureFormat.RGBA32, false);
            Color[] pixels = new Color[width * height];

            // Fill white background
            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = Color.white;

            List<TileRenderInstruction> instructions =
                TileCommandParser.Parse(def.CommandScript);

            foreach (TileRenderInstruction instruction in instructions)
            {
                switch (instruction)
                {
                    case RectangleInstruction rectangle:
                        RasterizeRectangle(rectangle, pixels, width, height);
                        break;

                    case EllipseInstruction ellipse:
                        RasterizeEllipse(ellipse, pixels, width, height);
                        break;

                    case PieInstruction pie:
                        RasterizePie(pie, pixels, width, height);
                        break;

                    case BezierInstruction bezier:
                        RasterizeBezier(bezier, pixels, width, height);
                        break;
                }
            }

            texture.SetPixels(pixels);
            texture.Apply();

            return texture;
        }

        #region Rasterizers

        private static void RasterizeRectangle(
            RectangleInstruction rect,
            Color[] pixels,
            int width,
            int height)
        {
            int cx = Mathf.RoundToInt(rect.Center.x * width);
            int cy = Mathf.RoundToInt(rect.Center.y * height);

            int sx = Mathf.RoundToInt(rect.Size.x * width * 0.5f);
            int sy = Mathf.RoundToInt(rect.Size.y * height * 0.5f);

            for (int y = cy - sy; y < cy + sy; y++)
            {
                if (y < 0 || y >= height)
                    continue;

                for (int x = cx - sx; x < cx + sx; x++)
                {
                    if (x < 0 || x >= width)
                        continue;

                    pixels[y * width + x] = Color.black;
                }
            }
        }

        private static void RasterizeEllipse(
            EllipseInstruction ellipse,
            Color[] pixels,
            int width,
            int height)
        {
            int cx = Mathf.RoundToInt(ellipse.Center.x * width);
            int cy = Mathf.RoundToInt(ellipse.Center.y * height);

            float rx = ellipse.Size.x * width * 0.5f;
            float ry = ellipse.Size.y * height * 0.5f;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    float dx = (x - cx) / rx;
                    float dy = (y - cy) / ry;

                    if (dx * dx + dy * dy <= 1f)
                        pixels[y * width + x] = Color.black;
                }
            }
        }

        private static void RasterizePie(
            PieInstruction pie,
            Color[] pixels,
            int width,
            int height)
        {
            int cx = Mathf.RoundToInt(pie.Center.x * width);
            int cy = Mathf.RoundToInt(pie.Center.y * height);

            float rx = pie.Size.x * width * 0.5f;
            float ry = pie.Size.y * height * 0.5f;

            float start = pie.StartAngle;
            float end = start + pie.SweepAngle;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    float dx = x - cx;
                    float dy = y - cy;

                    float nx = dx / rx;
                    float ny = dy / ry;

                    if (nx * nx + ny * ny > 1f)
                        continue;

                    float angle = Mathf.Atan2(dy, dx) * Mathf.Rad2Deg;
                    if (angle < 0)
                        angle += 360f;

                    if (IsAngleWithin(angle, start, end))
                        pixels[y * width + x] = Color.black;
                }
            }
        }

        private static bool IsAngleWithin(float angle, float start, float end)
        {
            if (end < start)
                end += 360f;

            if (angle < start)
                angle += 360f;

            return angle >= start && angle <= end;
        }

        private static void RasterizeBezier(
            BezierInstruction bezier,
            Color[] pixels,
            int width,
            int height)
        {
            const int segments = 32;

            Vector2 prev = bezier.P0;

            for (int i = 1; i <= segments; i++)
            {
                float t = i / (float)segments;
                Vector2 point = EvaluateBezier(bezier, t);

                DrawThickLine(prev, point, bezier.Thickness, pixels, width, height);

                prev = point;
            }
        }

        private static Vector2 EvaluateBezier(BezierInstruction b, float t)
        {
            float u = 1f - t;

            return
                u * u * u * b.P0 +
                3f * u * u * t * b.P1 +
                3f * u * t * t * b.P2 +
                t * t * t * b.P3;
        }

        private static void DrawThickLine(
            Vector2 a,
            Vector2 b,
            float thickness,
            Color[] pixels,
            int width,
            int height)
        {
            int steps = 16;

            for (int i = 0; i <= steps; i++)
            {
                float t = i / (float)steps;
                Vector2 p = Vector2.Lerp(a, b, t);

                int cx = Mathf.RoundToInt(p.x * width);
                int cy = Mathf.RoundToInt(p.y * height);

                int radius = Mathf.RoundToInt(thickness * width * 0.5f);

                for (int y = cy - radius; y <= cy + radius; y++)
                {
                    if (y < 0 || y >= height)
                        continue;

                    for (int x = cx - radius; x <= cx + radius; x++)
                    {
                        if (x < 0 || x >= width)
                            continue;

                        float dx = x - cx;
                        float dy = y - cy;

                        if (dx * dx + dy * dy <= radius * radius)
                            pixels[y * width + x] = Color.black;
                    }
                }
            }
        }

        #endregion
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTextureCooker.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileSet.cs ---

// TODO ROADMAP:
// [x] TileSet asset (collection of tiles)
// [ ] Add lookup by connectivity
// [ ] Add weighted lookup
// [ ] Add adjacency filtering helpers
// [ ] Add runtime dictionary cache

using UnityEngine;

namespace Truchet.Tiles
{
    [CreateAssetMenu(
        fileName = "TileSet",
        menuName = "Truchet/Tiles/Tile Set",
        order = 1)]
    public class TileSet : ScriptableObject
    {
        public Tile[] tiles;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\TileSet.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookerEditor.cs ---

// TODO ROADMAP:
// [x] Add cook button
// [x] Remove folder popup
// [ ] Add preview panel
// [ ] Add batch cook window
// [ ] Add atlas cook option

using UnityEditor;
using UnityEngine;

namespace Truchet.TileCooking
{
    [CustomEditor(typeof(TileCookDefinition))]
    public class TileCookerEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            var def = (TileCookDefinition)target;

            GUILayout.Space(10);

            if (GUILayout.Button("Cook Tile"))
            {
                TileTextureCooker.Cook(def);
            }
        }
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileCookerEditor.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\Tile.cs ---

// TODO ROADMAP:
// [x] Runtime tile asset (texture + connectivity)
// [ ] Add normal map support
// [ ] Add SDF texture support
// [ ] Add GPU index support
// [ ] Add metadata tags

using UnityEngine;

namespace Truchet.Tiles
{
    [CreateAssetMenu(
        fileName = "Tile",
        menuName = "Truchet/Tiles/Tile",
        order = 0)]
    public class Tile : ScriptableObject
    {
        [Tooltip("NESW bitmask")]
        public int connectivityMask;

        public Texture2D texture;
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Runtime\Tiles\Tile.cs ---

// --- Start File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTopology.cs ---

// TODO ROADMAP:
// [x] Simple NESW topology struct
// [ ] Add helper methods
// [ ] Add rotation helpers
// [ ] Add compatibility check

using UnityEngine;

namespace Truchet.TileCooking
{
    [System.Serializable]
    public struct TileTopology
    {
        public bool north;
        public bool east;
        public bool south;
        public bool west;

        public int Mask =>
            (north ? 1 : 0) |
            (east  ? 2 : 0) |
            (south ? 4 : 0) |
            (west  ? 8 : 0);
    }
}

// --- End File: Unity\TruchetTiles\Assets\Core\Editor\TileCooking\TileTopology.cs ---


--------------------------------------------------
// --- Prompt ---

You are continuing development of an existing module.

Context:
- I provide a blob of files representing the current implementation state.
- The module already has working functionality.
- There is an existing architecture and design philosophy (see included markdown).
- Your task is to analyze and continue structured development.

Your responsibilities:

1. Code Review (Concise)
   - Evaluate structure, architecture, cohesion, and clarity.
   - Identify architectural weaknesses, coupling issues, or scalability risks.
   - Do NOT rewrite everything unless necessary.
   - Be precise and technical.

2. Architecture Validation
   - Validate alignment with the design markdown and stated constraints.
   - Identify violations or future bottlenecks.

3. Roadmap Construction
   - Build a prioritized development roadmap.
   - Group features into phases (Foundation / Extension / Advanced).
   - Focus on extensibility and long-term scalability.

4. Step-by-Step Implementation Mode
   - Provide ONE implementation step per message.
   - Each step must:
        • Be small and focused
        • Include reasoning
        • Include full code listing for changed files
        • Start each file/class with a TODO roadmap block
   - After each step, stop and ask for confirmation before continuing.

5. Development Constraints
   - Favor modularity and separation of concerns.
   - Avoid hidden coupling between systems.
   - Avoid refresh-loop or asset pipeline side effects.
   - Keep deterministic rebuild behavior.
   - Design for future expansion (animation, metadata, addressables, etc.).

6. Best Practices
   - Recommend architectural patterns where applicable.
   - Suggest refactors only if they improve extensibility.
   - Avoid premature optimization.

7. Communication Style
   - Be concise.
   - No filler.
   - No long explanations unless necessary.
   - High signal, low noise.
   - Assume senior-level development context.

8. Markdown Awareness
   - Respect documented architecture rules.
   - Do not contradict design constraints.
   - If you suggest deviation, justify clearly.

Important:
This is an ongoing development session.
Treat the current code as a living module, not a prototype.
Build on it incrementally.